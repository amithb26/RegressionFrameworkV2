# SnaproutePhase1
Test Automation Framework
SNAPROUTE PHASE-1
This framework is developed for writing automation test suites for FlexSwitch devices.It utilizes the Python SDK provided by the FlexSwitch and uses the easy to learn , quick and fast implementation of Robot Framework for Test Automation. It supports both Docker and Hardware implementation. It can have different testbed files for different test scenarios. 
The testbed details are saved in JSON format in 'testbed' folder.

The folder structure of the framework is as shown below

- lib       : This folder consists of all the python API's required for configuring a FlexSwitch device.
- results   : This folder has the log files generated by the Robot Framework for every execution with the datestamp.
- run       : This folder consists of files to perform initial installation and also shell script to run the automation test cases.
- testbed   : This folder consists of different testbed files which correspond to different lab scenarios.
- testcases : This folder consists of the Robot test files and files required for writing .


This Framework is designed with familiar look and feel of the FlexSwitch Python SDK and data modelling. This implementation 
reduces the adapting duration by a significant value.


Usage and file description:
1) testbed.json  :- The testbed file captures all the details of the devices. This file is used by the framework to get all the
                 necessary details in order to connect and to understand the topology. This file basically consists of 
                 device details and link details. The hierarchy of the details is a mandate and should be kept as per 
                 the testbed included. Whereas the naming convention of the devices and links can be changed or added as per
                 the requirements. Any number of 'key, value' pairs can be added to any parameter in the testbed file and the
                 framework will not mind it. 

2) install.sh   :- This file is used to check if the host machine has the necessary services running on it. The services
                required for the Framework are Robot Framework nd Docker. If the services are not installed, the 'install.sh'
                file installs it. Just execute this file as any script file. This file is in run folder.
					
3) dockersetup.py :- This file reads the testbed file and checks if the described topology is docker or a harware setup. If it 
                is a docker setup, it instantiates docker instances based on the details from the testbed.json file and also
                creates links, ports and connects them to the docker. Just execute this file as any Python module.
					
4) test.sh       :- In order to execute a testcase one has to run the shell file 'test.sh' which is in 'run' folder. This shell
                file takes two arguments. One is the absolute path to the testbed file and absolutep path of the robot testcase
                file.
		            Example: test.sh /<path to testbed file>/testbed1.json /<path to thetestcase file>/
		            usecase1.robot
		            This testbed path is first set as an environment variable with name "TESTBED" which is then used by the 
                Framework for the rest of the execution.

5) testbedscan.py :- This file scans the testbed file for any syntax errors and also checks if the links and the ports
                 description are defined correctly. It performs different checks on the testbed.json file.
                 testbedCheck1:- Checks if the devices mentioned in the links exist in device list
				         Example: Device list= [DUT1,DUT2]. correct: DUT1_DUT2_1 wrong: DUT1_DUT3_1
	               testbedCheck2:- Checks if the interface description mentioned for a link is correct.
				         Example: Link = DUT1_DUT2_1.  
				         Correct: DUT1 : {intf:DUT1_P1,speed: 40G}  wrong: DUT1 : {intf:DUT1_P1,speed: 40G}
				                  DUT2 : {intf:DUT2_P1,speed: 40G}         DUT3 : {intf:DUT2_P1,speed: 40G}
	               testbedCheck3:- Checks if the management IP mentioned for the devices is a valid IP
				         correct: 10.0.0.1   wrong: 10.0..1
		             testbedCheck4:- Checks if duplicate ports are mentioned for same interface in two links
		             testbedCheck5:- Checks if duplicate ports are mentioned for interfaces of same device in ports list.
				         Example: correct: "ports" : {                       wrong: "ports"   : {
				                                  "D1_P1" : "fpPort25",                        "D1_P1" : "fpPort25",
				                                  "D1_P2" : "fpPort65" }                       "D1_P2" : "fpPort25" }
